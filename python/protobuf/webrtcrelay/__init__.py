# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: webrtc-relay.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Status(betterproto.Enum):
    OK = 0
    ERROR = 1


class PeerConnErrorTypes(betterproto.Enum):
    CONNECTION_CLOSED = 0
    UNKNOWN_ERROR = 1
    INVALID_RELAY_PEER_CONFIG_ID = 2
    INVALID_TARGET_PEERID = 3
    PEER_NOT_FOUND = 4
    CONNECTION_NOT_OPEN = 5
    NETWORK_ERROR = 6


class RelayErrorTypes(betterproto.Enum):
    UNKNOWN = 0
    INVALID_CONFIG = 1
    SERVER_NOT_FOUND = 2
    INVALID_PEERID = 3
    RELAY_DESTROYED = 4


@dataclass(eq=False, repr=False)
class RtcpFeedback(betterproto.Message):
    type: str = betterproto.string_field(1)
    """
    Type is the type of feedback. see: https://draft.ortc.org/#dom-
    rtcrtcpfeedback valid: ack, ccm, nack, goog-remb, transport-cc
    """

    parameter: str = betterproto.string_field(2)
    """
    The parameter value depends on the type. For example, type="nack"
    parameter="pli" will send Picture Loss Indicator packets.
    """


@dataclass(eq=False, repr=False)
class RtpCodecParams(betterproto.Message):
    """
    RTPCodecParameters is a sequence containing the media codecs that an
    RtpSender will choose from, as well as entries for RTX, RED and FEC
    mechanisms. This also includes the PayloadType that has been negotiated
    https://w3c.github.io/webrtc-pc/#rtcrtpcodecparameters RTPCodecCapability
    provides information about codec capabilities.
    https://w3c.github.io/webrtc-pc/#dictionary-rtcrtpcodeccapability-members
    """

    mime_type: str = betterproto.string_field(1)
    clock_rate: Optional[int] = betterproto.uint32_field(
        2, optional=True, group="_ClockRate"
    )
    channels: Optional[int] = betterproto.uint32_field(
        3, optional=True, group="_Channels"
    )
    sdp_fmtp_line: Optional[str] = betterproto.string_field(
        4, optional=True, group="_SDPFmtpLine"
    )
    rtcp_feedback: List["RtcpFeedback"] = betterproto.message_field(5)
    payload_type: Optional[int] = betterproto.uint32_field(
        6, optional=True, group="_PayloadType"
    )


@dataclass(eq=False, repr=False)
class TrackInfo(betterproto.Message):
    name: str = betterproto.string_field(1)
    kind: str = betterproto.string_field(2)
    codec: "RtpCodecParams" = betterproto.message_field(3)
    rtp_source_url: Optional[str] = betterproto.string_field(
        4, optional=True, group="_rtpSourceUrl"
    )


@dataclass(eq=False, repr=False)
class MsgRecivedEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when a message is received from any
    peer connected to any relayPeer on this webrtc-relay
    """

    src_peer_id: str = betterproto.string_field(1)
    relay_peer_number: int = betterproto.uint32_field(2)
    payload: bytes = betterproto.bytes_field(3)


@dataclass(eq=False, repr=False)
class RelayConnectedEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when any relayPeer on this webrtc-relay
    successfully (re)connects to the peerjs server it is setup to connect to
    """

    relay_peer_number: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class RelayDisconnectedEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when  any relayPeer on this webrtc-
    relay disconnects from the peerjs server it is setup to connect to
    """

    relay_peer_number: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class RelayErrorEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when a relayPeer encounters an error
    """

    relay_peer_number: int = betterproto.uint32_field(1)
    type: "RelayErrorTypes" = betterproto.enum_field(2)
    msg: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class PeerConnectedEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when a peer connects to (or is
    succesfully connected to by) any relayPeer on this webrtc-relay
    """

    relay_peer_number: int = betterproto.uint32_field(1)
    src_peer_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class PeerDisconnectedEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when a peer disconnects from any
    relayPeer on this webrtc-relay
    """

    relay_peer_number: int = betterproto.uint32_field(1)
    src_peer_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class PeerCalledEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when a peer opens a media call with any
    relayPeer on this webrtc-relay
    """

    relay_peer_number: int = betterproto.uint32_field(1)
    src_peer_id: str = betterproto.string_field(2)
    stream_name: str = betterproto.string_field(3)
    tracks: List["TrackInfo"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class PeerHungupEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when a peer hangs up an open media call
    with any relayPeer on this webrtc-relay
    """

    relay_peer_number: int = betterproto.uint32_field(1)
    src_peer_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class PeerDataConnErrorEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when any data connection to a remote
    peer encounters an error
    """

    relay_peer_number: int = betterproto.uint32_field(1)
    src_peer_id: str = betterproto.string_field(2)
    type: "PeerConnErrorTypes" = betterproto.enum_field(3)
    msg: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class PeerMediaConnErrorEvent(betterproto.Message):
    """
    RelayEventStream event that is sent when any media connection to a remote
    peer encounters an error
    """

    relay_peer_number: int = betterproto.uint32_field(1)
    src_peer_id: str = betterproto.string_field(2)
    type: "PeerConnErrorTypes" = betterproto.enum_field(3)
    msg: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class RelayEventStream(betterproto.Message):
    exchange_id: Optional[int] = betterproto.uint32_field(
        1, optional=True, group="_exchangeId"
    )
    msg_recived: "MsgRecivedEvent" = betterproto.message_field(2, group="event")
    relay_connected: "RelayConnectedEvent" = betterproto.message_field(3, group="event")
    relay_disconnected: "RelayDisconnectedEvent" = betterproto.message_field(
        4, group="event"
    )
    relay_error: "RelayErrorEvent" = betterproto.message_field(5, group="event")
    peer_connected: "PeerConnectedEvent" = betterproto.message_field(8, group="event")
    peer_disconnected: "PeerDisconnectedEvent" = betterproto.message_field(
        9, group="event"
    )
    peer_called: "PeerCalledEvent" = betterproto.message_field(10, group="event")
    peer_hungup: "PeerHungupEvent" = betterproto.message_field(11, group="event")
    peer_data_conn_error: "PeerDataConnErrorEvent" = betterproto.message_field(
        12, group="event"
    )
    peer_media_conn_error: "PeerMediaConnErrorEvent" = betterproto.message_field(
        13, group="event"
    )


@dataclass(eq=False, repr=False)
class EventStreamRequest(betterproto.Message):
    """EventStreamRequest should be sent empty (no fields used)"""

    pass


@dataclass(eq=False, repr=False)
class ConnectionRequest(betterproto.Message):
    peer_id: str = betterproto.string_field(1)
    relay_peer_number: Optional[int] = betterproto.uint32_field(
        2, optional=True, group="_relayPeerNumber"
    )
    exchange_id: Optional[int] = betterproto.uint32_field(
        4, optional=True, group="_exchangeId"
    )


@dataclass(eq=False, repr=False)
class ConnectionResponse(betterproto.Message):
    status: "Status" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class CallRequest(betterproto.Message):
    target_peer_ids: List[str] = betterproto.string_field(1)
    stream_name: str = betterproto.string_field(2)
    relay_peer_number: Optional[int] = betterproto.uint32_field(
        3, optional=True, group="_relayPeerNumber"
    )
    exchange_id: Optional[int] = betterproto.uint32_field(
        4, optional=True, group="_exchangeId"
    )
    tracks: List["TrackInfo"] = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class CallResponse(betterproto.Message):
    status: "Status" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class HangupRequest(betterproto.Message):
    peer_id: str = betterproto.string_field(2)
    relay_peer_number: Optional[int] = betterproto.uint32_field(
        1, optional=True, group="_relayPeerNumber"
    )
    exchange_id: Optional[int] = betterproto.uint32_field(
        4, optional=True, group="_exchangeId"
    )


@dataclass(eq=False, repr=False)
class HangupResponse(betterproto.Message):
    peer_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class SendMsgRequest(betterproto.Message):
    target_peer_ids: List[str] = betterproto.string_field(1)
    payload: bytes = betterproto.bytes_field(2)
    relay_peer_number: Optional[int] = betterproto.uint32_field(
        3, optional=True, group="_relayPeerNumber"
    )
    exchange_id: Optional[int] = betterproto.uint32_field(
        4, optional=True, group="_exchangeId"
    )


@dataclass(eq=False, repr=False)
class SendMsgResponse(betterproto.Message):
    status: "Status" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class RelayConfig(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class AddRelayRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class RelayPeerNumber(betterproto.Message):
    number: int = betterproto.uint32_field(1)


class WebRtcRelayStub(betterproto.ServiceStub):
    async def get_event_stream(
        self,
        event_stream_request: "EventStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RelayEventStream"]:
        async for response in self._unary_stream(
            "/webrtcrelay.WebRTCRelay/GetEventStream",
            event_stream_request,
            RelayEventStream,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def connect_to_peer(
        self,
        connection_request: "ConnectionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConnectionResponse":
        return await self._unary_unary(
            "/webrtcrelay.WebRTCRelay/ConnectToPeer",
            connection_request,
            ConnectionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def disconnect_from_peer(
        self,
        connection_request: "ConnectionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConnectionResponse":
        return await self._unary_unary(
            "/webrtcrelay.WebRTCRelay/DisconnectFromPeer",
            connection_request,
            ConnectionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def call_peer(
        self,
        call_request: "CallRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CallResponse":
        return await self._unary_unary(
            "/webrtcrelay.WebRTCRelay/CallPeer",
            call_request,
            CallResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def hangup_peer(
        self,
        connection_request: "ConnectionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CallResponse":
        return await self._unary_unary(
            "/webrtcrelay.WebRTCRelay/HangupPeer",
            connection_request,
            CallResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_msg_stream(
        self,
        send_msg_request_iterator: Union[
            AsyncIterable["SendMsgRequest"], Iterable["SendMsgRequest"]
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConnectionResponse":
        return await self._stream_unary(
            "/webrtcrelay.WebRTCRelay/SendMsgStream",
            send_msg_request_iterator,
            SendMsgRequest,
            ConnectionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def add_relay_peer(
        self,
        add_relay_request: "AddRelayRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RelayErrorEvent":
        return await self._unary_unary(
            "/webrtcrelay.WebRTCRelay/AddRelayPeer",
            add_relay_request,
            RelayErrorEvent,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def close_relay_peer(
        self,
        relay_peer_number: "RelayPeerNumber",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RelayErrorEvent":
        return await self._unary_unary(
            "/webrtcrelay.WebRTCRelay/CloseRelayPeer",
            relay_peer_number,
            RelayErrorEvent,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_relay_peer_config(
        self,
        relay_peer_number: "RelayPeerNumber",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RelayConfig":
        return await self._unary_unary(
            "/webrtcrelay.WebRTCRelay/GetRelayPeerConfig",
            relay_peer_number,
            RelayConfig,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class WebRtcRelayBase(ServiceBase):
    async def get_event_stream(
        self, event_stream_request: "EventStreamRequest"
    ) -> AsyncIterator["RelayEventStream"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def connect_to_peer(
        self, connection_request: "ConnectionRequest"
    ) -> "ConnectionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def disconnect_from_peer(
        self, connection_request: "ConnectionRequest"
    ) -> "ConnectionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def call_peer(self, call_request: "CallRequest") -> "CallResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def hangup_peer(
        self, connection_request: "ConnectionRequest"
    ) -> "CallResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_msg_stream(
        self, send_msg_request_iterator: AsyncIterator["SendMsgRequest"]
    ) -> "ConnectionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_relay_peer(
        self, add_relay_request: "AddRelayRequest"
    ) -> "RelayErrorEvent":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def close_relay_peer(
        self, relay_peer_number: "RelayPeerNumber"
    ) -> "RelayErrorEvent":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_relay_peer_config(
        self, relay_peer_number: "RelayPeerNumber"
    ) -> "RelayConfig":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_event_stream(
        self, stream: "grpclib.server.Stream[EventStreamRequest, RelayEventStream]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_event_stream,
            stream,
            request,
        )

    async def __rpc_connect_to_peer(
        self, stream: "grpclib.server.Stream[ConnectionRequest, ConnectionResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.connect_to_peer(request)
        await stream.send_message(response)

    async def __rpc_disconnect_from_peer(
        self, stream: "grpclib.server.Stream[ConnectionRequest, ConnectionResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.disconnect_from_peer(request)
        await stream.send_message(response)

    async def __rpc_call_peer(
        self, stream: "grpclib.server.Stream[CallRequest, CallResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.call_peer(request)
        await stream.send_message(response)

    async def __rpc_hangup_peer(
        self, stream: "grpclib.server.Stream[ConnectionRequest, CallResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.hangup_peer(request)
        await stream.send_message(response)

    async def __rpc_send_msg_stream(
        self, stream: "grpclib.server.Stream[SendMsgRequest, ConnectionResponse]"
    ) -> None:
        request = stream.__aiter__()
        response = await self.send_msg_stream(request)
        await stream.send_message(response)

    async def __rpc_add_relay_peer(
        self, stream: "grpclib.server.Stream[AddRelayRequest, RelayErrorEvent]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_relay_peer(request)
        await stream.send_message(response)

    async def __rpc_close_relay_peer(
        self, stream: "grpclib.server.Stream[RelayPeerNumber, RelayErrorEvent]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.close_relay_peer(request)
        await stream.send_message(response)

    async def __rpc_get_relay_peer_config(
        self, stream: "grpclib.server.Stream[RelayPeerNumber, RelayConfig]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_relay_peer_config(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/webrtcrelay.WebRTCRelay/GetEventStream": grpclib.const.Handler(
                self.__rpc_get_event_stream,
                grpclib.const.Cardinality.UNARY_STREAM,
                EventStreamRequest,
                RelayEventStream,
            ),
            "/webrtcrelay.WebRTCRelay/ConnectToPeer": grpclib.const.Handler(
                self.__rpc_connect_to_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConnectionRequest,
                ConnectionResponse,
            ),
            "/webrtcrelay.WebRTCRelay/DisconnectFromPeer": grpclib.const.Handler(
                self.__rpc_disconnect_from_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConnectionRequest,
                ConnectionResponse,
            ),
            "/webrtcrelay.WebRTCRelay/CallPeer": grpclib.const.Handler(
                self.__rpc_call_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                CallRequest,
                CallResponse,
            ),
            "/webrtcrelay.WebRTCRelay/HangupPeer": grpclib.const.Handler(
                self.__rpc_hangup_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConnectionRequest,
                CallResponse,
            ),
            "/webrtcrelay.WebRTCRelay/SendMsgStream": grpclib.const.Handler(
                self.__rpc_send_msg_stream,
                grpclib.const.Cardinality.STREAM_UNARY,
                SendMsgRequest,
                ConnectionResponse,
            ),
            "/webrtcrelay.WebRTCRelay/AddRelayPeer": grpclib.const.Handler(
                self.__rpc_add_relay_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddRelayRequest,
                RelayErrorEvent,
            ),
            "/webrtcrelay.WebRTCRelay/CloseRelayPeer": grpclib.const.Handler(
                self.__rpc_close_relay_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                RelayPeerNumber,
                RelayErrorEvent,
            ),
            "/webrtcrelay.WebRTCRelay/GetRelayPeerConfig": grpclib.const.Handler(
                self.__rpc_get_relay_peer_config,
                grpclib.const.Cardinality.UNARY_UNARY,
                RelayPeerNumber,
                RelayConfig,
            ),
        }
